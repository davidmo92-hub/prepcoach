import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

interface InterviewResponse {
  question: string;
  audioURL: string | null;
  duration: number;
  feedback?: string;
  timestamp: number;
}

interface InterviewSession {
  id: string;
  roleTitle: string;
  roleCategory: string;
  roleLevel: string;
  company: string;
  date: number;
  responses: InterviewResponse[];
  completionRate: number;
  totalQuestions: number;
  answeredQuestions: number;
}

// Export single session to PDF
export const exportSessionToPDF = (session: InterviewSession) => {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();

  // Header
  doc.setFillColor(249, 115, 22); // Orange
  doc.rect(0, 0, pageWidth, 40, 'F');

  doc.setTextColor(255, 255, 255);
  doc.setFontSize(24);
  doc.setFont('helvetica', 'bold');
  doc.text('PrepCoach Interview Report', pageWidth / 2, 20, { align: 'center' });

  doc.setFontSize(12);
  doc.setFont('helvetica', 'normal');
  doc.text('AI-Powered Interview Practice Platform', pageWidth / 2, 30, { align: 'center' });

  // Session Info
  let yPos = 55;
  doc.setTextColor(0, 0, 0);
  doc.setFontSize(18);
  doc.setFont('helvetica', 'bold');
  doc.text(session.roleTitle, 14, yPos);

  yPos += 8;
  doc.setFontSize(11);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(100, 100, 100);
  doc.text(`${session.company} • ${session.roleLevel} • ${session.roleCategory}`, 14, yPos);

  yPos += 6;
  doc.text(`Date: ${new Date(session.date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  })}`, 14, yPos);

  // Stats Box
  yPos += 12;
  doc.setFillColor(243, 244, 246);
  doc.roundedRect(14, yPos, pageWidth - 28, 22, 3, 3, 'F');

  yPos += 8;
  doc.setFontSize(10);
  doc.setTextColor(0, 0, 0);
  doc.setFont('helvetica', 'bold');
  doc.text(`Completion Rate: ${session.completionRate}%`, 20, yPos);
  doc.text(`Questions Answered: ${session.answeredQuestions}/${session.totalQuestions}`, pageWidth / 2, yPos);

  yPos += 7;
  const feedbackCount = session.responses.filter(r => r.feedback).length;
  doc.text(`AI Feedback Received: ${feedbackCount}`, 20, yPos);

  // Questions and Responses
  yPos += 20;
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('Interview Questions & Responses', 14, yPos);

  yPos += 10;

  session.responses.forEach((response, index) => {
    // Check if we need a new page
    if (yPos > 250) {
      doc.addPage();
      yPos = 20;
    }

    // Question
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(249, 115, 22);
    doc.text(`Q${index + 1}:`, 14, yPos);

    doc.setTextColor(0, 0, 0);
    doc.setFont('helvetica', 'normal');
    const questionLines = doc.splitTextToSize(response.question, pageWidth - 35);
    doc.text(questionLines, 25, yPos);
    yPos += questionLines.length * 5 + 3;

    // Status
    if (response.audioURL) {
      doc.setFontSize(9);
      doc.setTextColor(34, 197, 94);
      doc.text(`✓ Answered (${Math.floor(response.duration / 60)}:${(response.duration % 60).toString().padStart(2, '0')})`, 25, yPos);
      yPos += 6;

      // Feedback
      if (response.feedback) {
        doc.setFontSize(10);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(59, 130, 246);
        doc.text('AI Feedback:', 25, yPos);
        yPos += 5;

        doc.setFont('helvetica', 'normal');
        doc.setFontSize(9);
        doc.setTextColor(75, 85, 99);
        const feedbackLines = doc.splitTextToSize(response.feedback, pageWidth - 35);

        // Limit feedback to avoid overflow
        const maxLines = Math.min(feedbackLines.length, 15);
        doc.text(feedbackLines.slice(0, maxLines), 25, yPos);
        yPos += maxLines * 4;

        if (feedbackLines.length > maxLines) {
          doc.setTextColor(156, 163, 175);
          doc.text('(Feedback truncated...)', 25, yPos);
          yPos += 4;
        }
      } else {
        doc.setFontSize(9);
        doc.setTextColor(156, 163, 175);
        doc.text('No AI feedback available', 25, yPos);
        yPos += 5;
      }
    } else {
      doc.setFontSize(9);
      doc.setTextColor(156, 163, 175);
      doc.text('✗ Not answered', 25, yPos);
      yPos += 6;
    }

    yPos += 8;
  });

  // Footer on last page
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(156, 163, 175);
    doc.text(
      `Generated by PrepCoach • Page ${i} of ${pageCount}`,
      pageWidth / 2,
      doc.internal.pageSize.getHeight() - 10,
      { align: 'center' }
    );
  }

  // Save
  const fileName = `PrepCoach_${session.roleTitle.replace(/[^a-z0-9]/gi, '_')}_${new Date(session.date).toISOString().split('T')[0]}.pdf`;
  doc.save(fileName);
};

// Export all sessions to CSV
export const exportAllSessionsToCSV = (sessions: InterviewSession[]) => {
  const headers = [
    'Date',
    'Role',
    'Company',
    'Level',
    'Category',
    'Completion Rate (%)',
    'Questions Answered',
    'Total Questions',
    'Feedback Count'
  ];

  const rows = sessions.map(session => {
    const feedbackCount = session.responses.filter(r => r.feedback).length;
    return [
      new Date(session.date).toLocaleString('en-US'),
      session.roleTitle,
      session.company,
      session.roleLevel,
      session.roleCategory,
      session.completionRate,
      session.answeredQuestions,
      session.totalQuestions,
      feedbackCount
    ];
  });

  const csvContent = [
    headers.join(','),
    ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
  ].join('\n');

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);

  link.setAttribute('href', url);
  link.setAttribute('download', `PrepCoach_All_Sessions_${new Date().toISOString().split('T')[0]}.csv`);
  link.style.visibility = 'hidden';

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

// Export single session to CSV
export const exportSessionToCSV = (session: InterviewSession) => {
  const headers = [
    'Question #',
    'Question',
    'Answered',
    'Duration (seconds)',
    'Has Feedback',
    'Feedback'
  ];

  const rows = session.responses.map((response, index) => [
    index + 1,
    response.question,
    response.audioURL ? 'Yes' : 'No',
    response.duration || 0,
    response.feedback ? 'Yes' : 'No',
    response.feedback ? response.feedback.replace(/"/g, '""') : ''
  ]);

  const csvContent = [
    `"Interview Report: ${session.roleTitle}"`,
    `"Company: ${session.company}"`,
    `"Date: ${new Date(session.date).toLocaleString('en-US')}"`,
    `"Completion Rate: ${session.completionRate}%"`,
    '',
    headers.join(','),
    ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
  ].join('\n');

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);

  const fileName = `PrepCoach_${session.roleTitle.replace(/[^a-z0-9]/gi, '_')}_${new Date(session.date).toISOString().split('T')[0]}.csv`;
  link.setAttribute('href', url);
  link.setAttribute('download', fileName);
  link.style.visibility = 'hidden';

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};
